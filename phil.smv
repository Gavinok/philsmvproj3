--
-- CSC 322 Project 3
--
-- Name: Ian Weber
-- Vnum: V00924748
--
--
MODULE main
  
VAR
  chopsticks : array 0..4 of {nobody,0,1,2,3,4}; -- who holds the chopstick.
  --
  -- Philosopher i has chopstick i on left and chopstick
  -- (i + 1) mod 5 on right
  --
  p0 : process philosopher(0,chopsticks[0],chopsticks[1]);
  p1 : process philosopher(1,chopsticks[1],chopsticks[2]);
  p2 : process philosopher(2,chopsticks[2],chopsticks[3]);
  p3 : process philosopher(3,chopsticks[3],chopsticks[4]);
  p4 : process philosopher(4,chopsticks[4],chopsticks[0]);
  
ASSIGN
  --
  -- Initially, all chopsticks are free
  --
  init(chopsticks[0]) := nobody;
  init(chopsticks[1]) := nobody;
  init(chopsticks[2]) := nobody;
  init(chopsticks[3]) := nobody;
  init(chopsticks[4]) := nobody;
    
MODULE philosopher(i,left,right)
  
VAR
  state : {thinking, hungry, eating, done};
  
DEFINE
  --
  -- These are just abbreviations, not state variables
  --
  gotleft := (left=i);
  gotright := (right=i);
  leftfree := (left=nobody);
  rightfree := (right=nobody);
    
ASSIGN
  init(state) := thinking;

  next(left)  := case
    (state = done) : nobody; -- drop chopstick
    --
    -- if hungry and left chopstick if free, take it
    --
    (state=hungry) & leftfree : i;
    TRUE : left;
  esac;

  next(right) := case
    (state = done) : nobody; -- drop chopstick
    --
    -- if hungry and have left chopstick and right is free, take it
    --
    (state=hungry) & gotleft & rightfree : i; 
    TRUE : right;
  esac;

  next(state) := case
    (state=thinking) : {thinking, hungry};
    (state=hungry) & gotleft & gotright : eating;
    (state=hungry) : hungry; -- don't have chopsticks
    (state=eating) : {eating, done};
    (state=done) : thinking;
    TRUE : state;
  esac;

-- add fairness constraints here

-- add specifications here 

-- safety:
-- Philosophers cannot eat without having chopsticks, we assume table manners
-- Adjacent philosophers cannot eat concurrently.
SPEC AG (p0.eating -> (p1.state = thinking | p1.state = hungry | p1.state = done))
SPEC AG (p1.eating -> (p2.state = thinking | p2.state = hungry | p2.state = done))
SPEC AG (p2.eating -> (p3.state = thinking | p3.state = hungry | p3.state = done))
SPEC AG (p3.eating -> (p4.state = thinking | p4.state = hungry | p4.state = done))
SPEC AG (p4.eating -> (p0.state = thinking | p0.state = hungry | p0.state = done))


-- liveness:
-- A hungry philosopher will inevitably eat.
SPEC AG(hungry -> AF eating)
-- A philosopher will inevitably eat when both chopsticks are available.
SPEC AG((!eating & leftfree & rightfree) -> AF eating)
-- Everyone who is hungry will ultimately have a chance to eat.
SPEC AG (hungry -> AF (p0.eating | p1.eating | p2.eating | p3.eating | p4.eating))
