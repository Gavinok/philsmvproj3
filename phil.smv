--
-- CSC 322 Project 3
--
-- Name: Ian Weber
-- Vnum: V00924748
--
--
MODULE main

VAR
  chopsticks : array 0..4 of {nobody,0,1,2,3,4}; -- who holds the chopstick.
  turn : 0..5; -- Chopstick lock
	       --
	       -- Philosopher i has chopstick i on left and chopstick
	       -- (i + 1) mod 5 on right
	       --
  p0 : process philosopher(0,chopsticks[0],chopsticks[1], turn);
  p1 : process philosopher(1,chopsticks[1],chopsticks[2], turn);
  p2 : process philosopher(2,chopsticks[2],chopsticks[3], turn);
  p3 : process philosopher(3,chopsticks[3],chopsticks[4], turn);
  p4 : process philosopher(4,chopsticks[4],chopsticks[0], turn);

ASSIGN
  --
  -- Initially, all chopsticks are free
  --
  init(chopsticks[0]) := nobody;
  init(chopsticks[1]) := nobody;
  init(chopsticks[2]) := nobody;
  init(chopsticks[3]) := nobody;
  init(chopsticks[4]) := nobody;

  -- Probably not necessary but set the inital pilisopher to philosopher 0
  init(turn) := 0;

SPEC AG !(p0.state = eating &  p1.state = eating)
SPEC AG !(p1.state = eating &  p2.state = eating)
SPEC AG !(p2.state = eating &  p3.state = eating)
SPEC AG !(p4.state = eating &  p0.state = eating)

MODULE philosopher(i,left,right,turn)

VAR
  state : {thinking, hungry, eating, done};

DEFINE
  --
  -- These are just abbreviations, not state variables
  --
  gotleft := (left=i);
  gotright := (right=i);
  leftfree := (left=nobody);
  rightfree := (right=nobody);
  bothfree := (leftfree & rightfree);

ASSIGN
  init(state) := thinking;

  next(left)  := case
		   (state = done) : nobody; -- drop chopstick
					    --
					    -- if hungry and left chopstick if free, take it
					    --
		   (state=hungry) & leftfree & (turn=i) : i;
		   TRUE : left;
		 esac;

  next(right) := case
		   (state = done) : nobody; -- drop chopstick
					    --
					    -- if hungry and have left chopstick and right is free, take it
					    --
		   (state=hungry) & gotleft & rightfree & (turn=i) : i;
		   TRUE : right;
		 esac;

  next(state) := case
		   (state=thinking) : {thinking, hungry};
		   (state=hungry) & gotleft & gotright: eating;
		   (state=hungry) : hungry; -- don't have chopsticks
		   (state=eating) : {eating, done};
		   (state=done) : thinking;
		   TRUE : state;
		 esac;

  next(turn) := case
		  -- rather than adding an if for every time it could be 4
		  (turn=5) : 0;
		  (turn=i) & (state=thinking) : i + 1;
		  (turn=i) & (state=done) & bothfree : i + 1;
		  TRUE : turn;
		esac;

-- add fairness constraints here
FAIRNESS !(state = eating)
FAIRNESS running

-- add specifications here

-- safety:
  -- Philosophers cannot eat without having chopsticks, we assume table manners
SPEC AG ((state = eating) -> (gotleft & gotright))


-- liveness:
  -- A hungry philosopher will inevitably eat.
SPEC AG(state = hungry -> AF state = eating)

-- additional spec:
  -- Assert no deadlock where one a philosopher indefinitely waits to
  -- get the right chopstick
SPEC !EF AG (state = hungry & gotleft & !gotright)