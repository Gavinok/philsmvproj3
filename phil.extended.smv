--
-- CSC 322 Project 3
--
-- Name: Ian Weber
-- Vnum: V00924748
--
--
MODULE main

VAR
  chopsticks : array 0..4 of {nobody,0,1,2,3,4}; -- who holds the chopstick.
  turn : array 0..4 of  0..4; -- Chopstick locks
	       --
	       -- Philosopher i has chopstick i on left and chopstick
	       -- (i + 1) mod 5 on right
	       --
  p0 : process philosopher(0,chopsticks[0],chopsticks[1], turn[0], turn[1]);
  p1 : process philosopher(1,chopsticks[1],chopsticks[2], turn[1], turn[2]);
  p2 : process philosopher(2,chopsticks[2],chopsticks[3], turn[2], turn[3]);
  p3 : process philosopher(3,chopsticks[3],chopsticks[4], turn[3], turn[4]);
  p4 : process philosopher(4,chopsticks[4],chopsticks[0], turn[4], turn[0]);

ASSIGN
  --
  -- Initially, all chopsticks are free
  --
  init(chopsticks[0]) := nobody;
  init(chopsticks[1]) := nobody;
  init(chopsticks[2]) := nobody;
  init(chopsticks[3]) := nobody;
  init(chopsticks[4]) := nobody;

  -- Probably not necessary but set the inital pilisopher to philosopher 0
  init(turn[1]) := 0;
  init(turn[2]) := 1;
  init(turn[3]) := 2;
  init(turn[4]) := 3;
  init(turn[0]) := 4;

MODULE philosopher(i,left,right,lturn, rturn)

VAR
  state : {thinking, hungry, eating, done};

DEFINE
  --
  -- These are just abbreviations, not state variables
  --
  gotleft := (left=i);
  gotright := (right=i);
  leftfree := (left=nobody);
  rightfree := (right=nobody);
  bothfree := (leftfree & rightfree);

ASSIGN
  init(state) := thinking;

  next(left)  := case
		   (state = done) : nobody; -- drop chopstick
					    --
					    -- if hungry and left chopstick if free, take it
					    --
		   (state=hungry) & leftfree & (lturn=i) : i;
		   TRUE : left;
		 esac;

  next(right) := case
		   (state = done) : nobody; -- drop chopstick
					    --
					    -- if hungry and have left chopstick and right is free, take it
					    --
		   (state=hungry) & gotleft & rightfree & (rturn=i) : i;
		   TRUE : right;
		 esac;

  next(state) := case
		   (state=thinking) : {thinking, hungry};
		   (state=hungry) & gotleft & gotright: eating;
		   (state=hungry) : hungry; -- don't have chopsticks
		   (state=eating) : {eating, done};
		   (state=done) : thinking;
		   TRUE : state;
		 esac;

  next(lturn) := case
		  -- rather than adding an if for every time it could be 4
		  (lturn=i) & (state=thinking) & (lturn=0): 4;
		  (lturn=i) & (state=thinking) : i - 1;
		  (lturn=i) & (state=done) & leftfree & (lturn=0): 4;
		  (lturn=i) & (state=done) & leftfree : i - 1;
		  TRUE : lturn;
		esac;
  next(rturn) := case
		  -- rather than adding an if for every time it could be 4
		  (rturn=i) & (state=thinking) & (rturn=4) : 0;
		  (rturn=i) & (state=thinking) : i + 1;
		  (rturn=i) & (state=done) & rightfree & (rturn=4): 0;
		  (rturn=i) & (state=done) & rightfree : i + 1;
		  TRUE : rturn;
		esac;

-- add fairness constraints here
FAIRNESS !(state = eating)
FAIRNESS running

-- add specifications here

  -- safety:
  -- Philosophers cannot eat without having chopsticks, we assume table manners
SPEC AG ((state = eating) -> (gotleft & gotright))


  -- liveness:
  -- A hungry philosopher will inevitably eat.
SPEC AG(state = hungry -> AF state = eating)

  -- additional constraints:
  -- Assert no deadlock where one a philosopher indefinitely waits to
  -- get the right chopstick
SPEC !EF AG (state = hungry & gotleft & !gotright)
